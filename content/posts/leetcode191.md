---
title: "191 位1的个数"
date: 2021-06-03T22:22:53+08:00
draft: false
tags: ["算法", "位运算"]
categories: ["技术"]

---

**题目**

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。

提示：

输入必须是长度为 32 的 二进制串 。

进阶：

如果多次调用这个函数，你将如何优化你的算法？

示例 2：
```
输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
```
示例 3：
```
输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
```
链接：https://leetcode-cn.com/problems/number-of-1-bits

**解题思路**

n & (n−1)，其运算结果恰为把 n 的二进制位中的最低位的 1 变为 0 之后的结果。

这样我们可以利用这个位运算的性质加速我们的检查过程，在实际代码中，我们不断让当前的 n 与 n - 1 做与运算，直到 n 变为 0 即可。因为每次运算会使得 n 的最低位的 1 被翻转，因此运算次数就等于 n 的二进制位中 1 的个数。


```python
class Solution(object):
    def hammingWeight(self, n):
        count = 0
        while n > 0:
            n = n & (n-1)
            count += 1
        return count
```

**复杂度分析**

时间复杂度：O(logn)。循环次数等于 n 的二进制位中 1 的个数，最坏情况下 n 的二进制位全部为 1。我们需要循环 logn 次。

空间复杂度：O(1)，我们只需要常数的空间保存若干变量。
