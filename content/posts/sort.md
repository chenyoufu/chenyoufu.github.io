---
title: "排序"
date: 2021-05-29T11:21:01+08:00
draft: false
tags: ["算法", "排序"]
categories: ["技术"]
---

**选择排序**
最容易理解。

首先，找到数组中最小的那个元素，其次，将它和数组的第 一个元素交换位置(如果第一个元素就是最小元素那么它就和自己交换)。再次，在剩下的元素中 找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法 叫做选择排序，因为它在不断地选择剩余元素之中的最小者。

如算法 2.1 所示，选择排序的内循环只是在比较当前元素与目前已知的最小元素(以及将当前 索引加 1 和检查是否代码越界)，这已经简单到了极点。交换元素的代码写在内循环之外，每次交 换都能排定一个元素，因此交换的总次数是 N。所以算法的时间效率取决于比较的次数。

```golang
func selectSort(a []int) {

  l := len(arr)
  for i:=0; i<l; i++ {
    min = a[i]
    for j:=i+1; j<l; j++ {
      if a[j] < min {
        min = a[j]
      }
    }
    a[i], a[j] = a[j], a[i]
  }

  return
}
```

**插入排序**

通常人们整理桥牌的方法是一张一张的来，将每一张牌插入到其他已经有序的牌中的适当位置。 在计算机的实现中，为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移 动一位。这种算法叫做插入排序，与选择排序一样，当前索引左边的所有元素都是有序的，但它们的最终位置还不确定，为了给 更小的元素腾出空间，它们可能会被移动。但是当索引到达数组的右端时，数组排序就完成了。

和选择排序不同的是，插入排序所需的时间取决于输入中元素的初始顺序。例如，对一个很大 且其中的元素已经有序(或接近有序)的数组进行排序将会比对随机顺序的数组或是逆序数组进行 排序要快得多。

```golang

func insertSort(a []int) {
  if a == nil {
    return
  }

  l := len(a)

  for i:=1; i<l; i++ {
    for j:=i-1; j >= 0 && a[i] < a[j]; j-- {
      a[j+1] = a[j] 
      a[j] = a[i]
    }
  }
  return
}
```

**冒泡排序**

```golang

func bubbleSort(arr []int) {

  l := len(arr)
  for i:=0; i<l; i++ {
    for j:=0; j<l-1-i; j++ {
      flag := true
      if a[j] < a[j+1] {
        a[j], a[j+1] = a[j+1], a[j]
        flag = false
      }
    }
    // 假如从开始的第一对到结尾的最后一对，相邻的元素之间都没有发生交换的操作，
    // 这意味着右边的元素总是大于等于左边的元素，此时的数组已经是有序的了，
    // 我们无需再对剩余的元素重复比较下去了。
    if flag {
      break
    }
  }
  return
}

```

